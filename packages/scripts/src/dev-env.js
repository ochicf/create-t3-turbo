// @ts-check
import fs from "fs/promises";
import dotenv from "dotenv";

/**
 * @template {string} Key
 * @typedef {() => string | Promise<string> | [string, ...[Key, FallbackFn<Key>][]]} FallbackFn
 */

/**
 * @template {string} Key
 * @param {[Key, FallbackFn<Key>][]} entries
 * @param {{
 *  log?: boolean,
 *  source?: string
 *  readme?: string
 *  title?: string,
 * }} options
 */
export function makeGetDevEnv(
  entries,
  {
    log = true,
    source = "/packages/scripts/src/dev-env.js",
    readme = "",
    title = `  Infering dev env variables from ${source}${readme && ` (see ${readme} for more info)`}:`,
  } = {},
) {
  return async () => {
    /** @type [Key, string][] */
    const fallbacks = [];
    return reduceEnvVarValues(entries, undefined, fallbacks).then(
      (result) => (
        log && fallbacks.length
          ? (console.log(title),
            fallbacks.forEach(([name, value]) =>
              console.log(`  - ${name}=${value}`),
            ))
          : void 0,
        result
      ),
    );
  };
}

/**
 * @template {string} Key
 * @param {[Key, FallbackFn<Key>][]} entries
 * @param {Partial<Record<Key, string>> | undefined} result
 * @param {[Key, string][]} fallbacks
 * @returns {Promise<Partial<Record<Key, string>>>}
 */
export function reduceEnvVarValues(entries, result = {}, fallbacks = []) {
  // @ts-expect-error: `reduce` call infering it's returning a tuple instead of the partial record?
  return entries.reduce(async (accPromise, [name, fallbackFn]) => {
    const acc = await accPromise;
    // eslint-disable-next-line no-restricted-properties
    const envValue = process.env[name];
    const fallbackOrEntries = envValue ?? (await fallbackFn());
    const [fallbackValue, ...fallbackEntries] = Array.isArray(fallbackOrEntries)
      ? fallbackOrEntries
      : [fallbackOrEntries];
    if (fallbackEntries.length) {
      await reduceEnvVarValues(fallbackEntries, acc, fallbacks);
    }
    // @ts-expect-error: not accepting the `string` value?
    acc[name] = fallbackValue;
    if (acc[name] !== envValue) {
      fallbacks.push([name, acc[name] ?? ""]);
    }
    return acc;
  }, Promise.resolve(result));
}

/**
 * @template {string} Key
 * @param {ReturnType<typeof makeGetDevEnv<Key>>[]} getDevEnvs
 * @param {Partial<Record<Key, string>>} result
 */
export async function makeDevEnv(getDevEnvs, result = {}) {
  return getDevEnvs.reduce(async (accPromise, getDevEnv) => {
    const acc = await accPromise;
    const devEnv = await getDevEnv();
    // @ts-expect-error: typed as `string` instead of `string | undefined`
    // eslint-disable-next-line no-restricted-properties
    dotenv.populate(process.env, devEnv);
    return { ...acc, ...devEnv };
  }, Promise.resolve(result));
}

const DEV_ENV_PREFIX = "[dev-env]";

/**
 *
 * @param {{
 *  filePath: string,
 *  devEnv: Record<string,string>,
 *  source?: string,
 *  title?: string,
 *  newline?: string
 * }} options
 */
export async function addDevEnvToFile({
  filePath,
  devEnv,
  source = "/packages/scripts/src/dev-env.js",
  title = `AUTOGENERATED BY ${source} -- DO NOT EDIT THIS LINE OR BELOW`,
  newline = "\n",
}) {
  let file;
  try {
    file = await fs.open(filePath, fs.constants.O_RDWR | fs.constants.O_CREAT);

    const separator = `# ${DEV_ENV_PREFIX} ${title}`;
    const previousContents = (await file.readFile("utf8")).replace(/\r/g, "");
    const [before = "", after = ""] = previousContents.includes(separator)
      ? previousContents.split(separator)
      : [previousContents];

    const prefix = before.replace(
      new RegExp(`${newline}{0,}$`),
      newline.repeat(2),
    );
    const suffix = after.slice(after.indexOf(`# ${DEV_ENV_PREFIX}`));

    const contents = [
      prefix,
      separator,
      newline,
      ...(Object.entries(devEnv)
        .map(([key, value]) => `${key}=${value}`)
        .join(newline) || "## No dev env variables infered"),
      newline,
      ...(suffix ? [newline, suffix] : []),
    ].join("");
    const written = await file.write(contents, 0, "utf8");
    await file.truncate(written.bytesWritten);
  } finally {
    await file?.close();
  }
}
